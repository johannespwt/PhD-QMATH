\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage{pdfpages}
\usepackage{mathrsfs}
\usepackage{amsfonts}
\usepackage{amsmath}
\DeclareMathOperator\arctanh{arctanh}
\usepackage{amssymb}
\usepackage{bbm}
\usepackage{amsthm}
\usepackage{graphicx}
\usepackage{centernot}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{braket}
\usepackage{pgfplots}
\usepackage{lastpage}
\usepackage{enumitem}
\usepackage{setspace}
\usepackage{xcolor}
\usepackage{cancel}
\usepackage{scrextend}
\usepackage[english]{babel} 

\usepackage[square,sort,comma,numbers]{natbib}
\usepackage[colorlinks=true,linkcolor=blue]{hyperref}

\usepackage{fancyhdr}
\newcommand{\euler}[1]{\text{e}^{#1}}
\newcommand{\Real}{\text{Re}}
\newcommand{\Imag}{\text{Im}}
\newcommand{\supp}{\text{supp}}
\newcommand{\pare}[1]{\left( #1 \right)}
\newcommand{\norm}[1]{\left\lVert #1 \right\rVert}
\newcommand{\abs}[1]{\left\lvert #1 \right\rvert}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\Span}[1]{\text{span}\left(#1\right)}
\newcommand{\dom}[1]{\mathscr D\left(#1\right)}
\newcommand{\Ran}[1]{\text{Ran}\left(#1\right)}
\newcommand{\conv}[1]{\text{co}\left\{#1\right\}}
\newcommand{\Ext}[1]{\text{Ext}\left\{#1\right\}}
\newcommand{\vin}{\rotatebox[origin=c]{-90}{$\in$}}
\newcommand{\vnotin}{\rotatebox[origin=c]{-90}{$\notin$}}
\newcommand{\interior}[1]{%
	{\kern0pt#1}^{\mathrm{o}}%
}
\newcommand*\diff{\mathop{}\!\mathrm{d}}
\newcommand{\ie}{\emph{i.e.} }
\newcommand{\eg}{\emph{e.g.} }
\newcommand{\dd}{\partial }
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\w}{\mathsf{w}}

\newcommand{\Gliminf}{\Gamma\text{-}\liminf}
\newcommand{\Glimsup}{\Gamma\text{-}\limsup}
\newcommand{\Glim}{\Gamma\text{-}\lim}
\newcommand{\pipe}{\ \vert \ }

\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}

\numberwithin{equation}{section}
\linespread{1.3}

\pagestyle{fancy}
\fancyhf{}
\rhead{CoCo - Exam 2016}
\lhead{}
\rfoot{\thepage}
\lfoot{Dated: \today}
\author{Johannes Agerskov}
\date{Dated: \today}
\title{CoCo - Exam 2016}
\begin{document}
	
	\maketitle
	\section*{Question 1}
	\subsection*{Part 1.1}
	Define $ B=\{s\pipe s\in \Sigma^*\wedge s\text{is balanced}\} $. We show that $ B $ is context free, but not regular.\begin{proof}
		$ B $ is generated by the CFG, $ G $\begin{equation}
		\begin{aligned}
		S\to (S)\pipe [S]\pipe SS\pipe
		\epsilon,
		\end{aligned}
		\end{equation}
		since this grammar generates any balanced set of parenthises and bracket. Clearly $ G $ generates only balanced expressions. On the contrary any balanced $ s $, we may identify the subexpressions of the form $ () $ or $ [] $, we may replace these by $ (S) $ and $ [S] $, we can now reverse the derivations and replace $ (S)\to S $ and $ [S]\to S $ and $ SS\to S $, and since $ s $ was balanced this can be continued until we are left with $ S $. This shows that any balanced $ S $ can be derived from from $ G $.   
	\end{proof}
	\subsection*{Part 1.2}
	$ B_e=\{s\pipe s\in B\wedge s\text{ has the same number of ( and [ }\} $.
	We show that $ B_e $ is not context free. \begin{proof}
		Assume for contradiction that $ B_e $ is context free, by the pumping lemma for CFLs, $ B_e $ has a pumping length $ p $. Consider the string $s= (^p)^p[^p]^p\in B_e $. According to the pumping lemma, this may be split in $ s=uvxyz $ such that $ \abs{vy}>0 $ and $ \abs{vxy}\leq p $ and such that $ uv^ixy^iz\in B_e $ for any $ i\in \N_0 $. Since $ \abs{xyz}\leq p $ we have that either $ vy $ contains only parenthises \emph{or} only $ ) $ and $ [ $ \emph{or} only brackets. In the first and last case, it cannot be pumped, since we would not have an equal number of parenthises and bracket. In the second case, it cannot be pumped, since $ uv^ixy^iz $ would not be balanced for $ i>1 $ or $ i=0 $. Thus we have obtained a contradiction and $ B_e $ cannot be context free.
	\end{proof}
	
	\subsection*{Part 1.3}
	Let $ P=\{s\pipe s\in B\wedge s\in \{(,)\}^*\} $ and $ P_3=\{s\pipe s\in P\wedge s\text{ has nesting depth }3\} $. We show that $ P_3 $ is regular.\begin{proof}
		We construct a DFA, that accepts $ P_3 $. The DFA consists of $ 6 $ states $ q_0 $, $ r $, $ 0 $, $ 1 $, $ 2 $, $ 3 $, $ \dot{1} $, $ \dot{2} $, $ \dot{3} $, where $ q_0 $ is the start state and $ r $ is a discard state and $ \dot{0} $ is the accepts state. We include then transitions function
		
		\begin{equation*}
			\begin{array}{l|l|l}
			\delta&(&)\\
			\hline
			q_0&1&r\\
			1&2&0\\
			2&3&1\\
			3&r&\dot{2}\\
			\dot{2}&\dot{3}&\dot{1}\\
			\dot{3}&r&\dot{2}\\
			\dot{1}&\dot{2}&\dot{0}\\
			\dot{0}&\dot{1}&r
			\end{array}
		\end{equation*}
		 Clearly if the nesting depth exceeds $ 3 $ the DFA rejects, if the nesting depts is below $ 3 $ the DFA rejects, and if the parenthesis is not balaced the DFA rejects. Thus it only accepts, for balanced parenthesis with nesting depth $ 3 $.
	\end{proof}
\subsection*{Part 1.4}
$ P $ is in $ L $\begin{proof}
	To check that $ s $ is balanced we construct log-space TM, $ M $, that does the following: "On input $ s $\begin{enumerate}
		\item Scan the input, while keeping a (binary) counter on the work tape, that increments 1 for every open parenthesis, and decrement $ 1 $ for every closed parenthises.
		\item If at any point the counter is $ 0 $ and a closed parenthises is read, \emph{reject.} 
		\item If the input is scanned completely and the counter is $ 0 $, \emph{accept}, else, \emph{reject.}
	\end{enumerate}
	Since the counter requires only log-space, this is clearly log-space, and evidently it accepts exactly $ P $. Clearly, $ M $ only accepts balanced inputs, since any closed parenthesis is matched by it closest open parethises on the left.
\end{proof}
\subsection*{Part 1.5}
$ B $ is in $ L $\begin{proof}
	Following the hint, we may construct the machine $ M' $ "On input $ s $\begin{enumerate}
		\item Run $ \tilde{M} $ on $ s $, where $ \tilde{M} $ is just $ M $ from before, but where it reads $ () $ and $ [] $ on equal footing.
		\item For each $ i=1 $ to $ n $ if $ a_i $ is open, find $ j $ such that $ a_j $ is the corresponding closing parenthises/bracket. Check that they are of the same kind. If true for all $ i $ \emph{accept}, if false for some $ i $ \emph{reject.}
		\end{enumerate}
		Evidently $ M' $ accepts $ s $ if and only if $ s $ is balanced.
\end{proof}
\section*{Question 2}
\subsection*{Part 2.1}
Define $ d\text{-}PCP $ as $ PCP $ but where a match is a collection of dominos such that the top string and bottom string have the same length but differ in at most $ d $ symbols.\\
We show that $ d\text{-}PCP $ is undecidable. \begin{proof}
	Consider the mapping reduction, given an instance of $ PCP $, produce the $ d\text{PCP} $ instance consisting of the set of dominos, which are identical to the ones in the $ PCP $ instance but with all symbols repeated $ d+1 $ times. This is clearly computable, since it is computed by decider TM that just copies everything $ d $ times. Clearly if the $ PCP $ instance have a match, the $ d\text{-}PCP $ instance have a corresponding match, which is in fact a  $ 0\text{-}match $ On the other hand since every symbol is $ d+1 $-fold, if the $ d\text{PCP} $ has a match, then every symbol must match,\ie it must be a $ 0\text{-}match $, since a single mismatch would automatically generate at least $ d+1 $ mismatches. Thus the original $ PCP $ instance also has a match. Therefore we see that this mapping reduction reduces $ PCP $ to $ d\text{-}PCP $ and $ PCP\leq_m d\text{-}PCP $. It then follows that $ d\text{PCP} $ is undecidable, since $ PCP $ is.
\end{proof}
\subsection*{Part 2.2}
We show that $ L_{erase} $ is co-Turing-recognizable.\begin{proof}
	We do this be mapping reduction from $ \overline{A_{TM}} $. Given $ \braket{M,w} $ construct the $ TM $, $ M' $ that ignores its input and simply print a special character, say $\aleph $ on the left most position on the tape. It then simulates $ M $ on input $ w $ on the rest of the tape, which is clearly possible in spite of the character on the leftmost position. Notice that this clearly is construction is computable.  If $ M $ accept, $ M' $ accepts, if $ M $ rejects, $ M' $ erase the entire tape and moves its head to the leftmost position (and then reject). Clearly if $ M\in\overline{A_{TM}} $ then $ M $ either rejects or runs forever. In either case, $ M' $ runs forever, or erases the entire tape and moves its head to the leftmost position. Thus $ M' $ is in $ L_{erase} $. On the contrary if $ M $ does accept $ w $ then $ M' $ will halt and never have an empty tape, so $ M' $ is not in $ L_{erase} $. Therefore, this constitutes a mapping reduction, $ \overline{A_{TM}}\leq_m L_{erase} $. Thus $ L_{erase} $ is co-Turing-recognizable. THIS SHOWS THAT $ L_{erase} $ IS NOT TURING-RECOGNIZABLE.
\end{proof}
\begin{proof}
Given $ \braket{M} $, construct $ M' $ that simulates $ M $ on all strings in parallel, if ever the tape is empty and the head is on the leftmost position in any of the simulations, $ M' $ terminates that simulation. If some simulation halts without being terminated, $ M' $ accepts. Clearly $ M' $ accepts $ \braket{M} $ if and only if there exist a string, $ w $ such that $ M $ halts on $ w $ without the tape have ever been empty witht he tapehead on the leftmost, positon. Thus $ M' $ accepts $ \overline{L_{erase}} $ and $ L_{erase} $ is co-Turing-recognizable.
\end{proof}
\subsection*{Part 2.3}
Let $ \braket{M}\in L_{erase} $ and define $ S=\{s\in\Sigma^*\pipe \exists w\in\Sigma^*, \text{such that }M\text{ halts on input $ w $ with $ s $ on its tape}\} $. We show that $ \abs{S}\leq\abs{Q} $, where $ Q$ is the set of states of $ M $.\begin{proof}
	Given any $ s\in S $ there exist $ w\in \Sigma^* $ and a computations history $ C_1,...,C_n $ of $ M $ on $ w $ such that $ s $ is tape content in $ C_n $. Furthermore, there exist $ k\leq n $ such that $ C_k=q $ for some $ q\in Q $. Now let $ w $ be the first string in lexicographical ordering, such that $ M $ halts on $ w $ with $ s $ on the tape. Let $ k_{min} $ be the minimal $ k $ such that $ C_{k_{min}}=q $ for some $ q\in Q $. Then the map $ s\mapsto q  $ is injective, since $ C_k=q $ fixes remaining computation history uniquely and therefore $ s $ is fixed, \ie given a $ q $ we may find $ s $, if it exists, by simulating $ M $ on the empty string, starting in state $ q $. Thus each $ q $ can be reached from at most one $ s $, and $ \abs{S}\leq \abs{Q} $. Notice each $ q $ need not give an $ s $, as $ M $ need not halt on $ \epsilon$ starting in state $ q $. 
\end{proof}

\section*{Question 3}
\subsection*{Part 3.1}
Let $ k $ be a natural number. We define \begin{equation*}
\begin{aligned}
	k\text{-}HAMPATH=\{\braket{G,s,t}\pipe G\text{ is a directed graph and there is a set of paths $ (\gamma_i)_{i=1}^{n} $, with $ n\leq k $}\\\text{in $ G $, such that one of the paths start at $ s $ and ends at $ t $,}\\\text{each path visit any vertex in $ G $ at most once,}\\\text{and any vertex in $ G $ is visited by at least one path} \}
\end{aligned}
\end{equation*}
We show that $ k\text{HAMPATH} $ belongs to NP. \begin{proof}
	We construct a polynomial time verifier for $ k-HAMPATH $. Consider the verifier $ V= $"On input $ (\braket{G,s,t},c) $\begin{enumerate}
		\item Verify that $ c $ is a collection of $ k $ or less paths in $ G $ (each of length less than or equal to the number of vertices in $ G $).
		\item Verfy that one of the paths start at $ s $ and end at $ t $.
		\item Verify that any of vertex of $ G $ is in one of the paths.
		\item Verify that all the paths visit any vertex in $ G $ at most once.
		\item If all the above are yes instances, \emph{accept}, else \emph{reject}.
	\end{enumerate}
	Step 1 runs in polynomial time, since it needs only check that there are $ k $ or less elements in $ c $ each of which consistist of valid paths in $ G $ that have length less than $ n=\abs{V(G)} $ Notice that there are at most $ n^2 $ edges in $ G $ to check for each edge in the path, and since we can reject of there are more than $ n $ edges, this can be done in at most $ O(n^3) $ time.  Step two is clealy polynomial in time. Step 3 is also clearly polynomial in time, as we can scan $ c $ for each vertex and $ c $ has at most lenght $ kn $. Step 4 is also a simple scanning procedure, so polynomial in time for each vertex. Thus this shows that $ k\text{-}HAMPATH $ is in NP. 
\end{proof}
\subsection*{Part 3.2}
We show that $ k\text{-}HAMPATH $ is NP-complete. \begin{proof}
	We proceed by polynomial time reducing from $ HAMPATH $, which is known to be NP-complete. Given input $ \braket{G,s,t} $, construct the graph $ \tilde{G} $ consisting of $ G $ with aditional $ k-1 $ vertices that are disconnected from the rest of $ \tilde{G} $. This can clearly be done by a polynomial time tranducer. Notice now that $ \braket{\tilde{G},s,t} $ is in $ k\text{-}HAMPATH $ if $ \braket{G,s,t} $ is in $ HAMPATH $, since the Hamiltionian path together with the collections of trivial paths that visit each of the extra vertices seperately, \ie paths that visit one and only one vertex each, constitutes the desired collection of at most $ k $ paths. On the contrary if $ \braket{\tilde{G},s,t} $ is in $ k\text{-}HAMPATH $, then there must be $k-1 $ trivial paths that visit one and only one node, and thus the last path must be a Hamiltonian path from $ s $ to $ t $ of $ G $, so that $ \braket{G,s,t} $ is in $ HAMPATH $. Thereby, it has been shown that $ HAMPATH\leq_Pk\text{-}HAMPATH $, and we conclude that $k\text{-}HAMPATH  $ is NP-hard. By Part 3.1 it follows that $ k\text{-}HAMPATH $ is NP-complete.  
\end{proof}
\subsection*{Part 3.3}
Let $ LADDER_{DFA} $ be the language of strings $ \braket{M,s,t} $ such that $ M $ is a DFA and $ L(M) $ contains a ladder of strings starting with string $ s $ and ending with string $ t $. We show that $ LADDER_{DFA} $ is in PSPACE.\begin{proof}
	By Savitch's theorem, PSAPCE$ = $NPSPACE, so we proceed by construction a polynomial space NTM that decides $ LADDER_{DFA} $. Simply consider $ N= $"On input $ \braket{M,s,t} $\begin{enumerate}
		\item Non-deterministically change a single character in $ s $, and run $ M $ on the new string while keeping a counter of how many times this step has been done on the branch. If $ M $ rejects, \emph{reject} that branch. If the new string is $ t $, \emph{accept}.
		\item  If the counter exceeds $ \abs{\Sigma}^n $ where $ n=\abs{s} $, then \emph{reject}.
	\end{enumerate}
	Clearly we can reject after $ \abs{\Sigma}^n $ changes, since there are at most $ \abs{\Sigma}^n $ different string of length $ n $, and therefore, if we do more changes than this, we are bound to loop on that branch.
	Clearly all steps uses polynomial space (DFA uses no space), and $ N $ is a decider since it is bound to reject at all branches if one of them have not accepted before step 2. Thus $ LADDER_{DFA} $ is in NPSPACE$ = $PSPACE.
\end{proof} 

\end{document}